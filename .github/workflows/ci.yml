name: CI

# Continuous Integration workflow
#
# This workflow runs on:
# - Pushes to main/master branches
# - Pull requests to main/master branches
# - Manual triggers via workflow_dispatch
#
# What it does:
# - Runs Rust code quality checks (check, test, fmt, clippy)
# - Builds all Docker image variants (base, cpu, minimal) for verification
# - Runs smoke tests on the CPU variant
#
# Important: This workflow does NOT push Docker images to GHCR
# Docker images are only pushed via the Release workflow when a version tag is pushed
#
# This ensures GHCR only contains released versions, not every CI build

on:
  push:
    branches: [ main, master ]
    paths:
      - 'src/**'
      - 'Cargo.toml'
      - 'Cargo.lock'
      - 'Dockerfile'
      - 'docker-setup.sh'
      - 'gtp_config.cfg.*'
      - 'analysis_config.cfg.*'
      - 'config.toml.example'
      - '.github/workflows/ci.yml'
  pull_request:
    branches: [ main, master ]
    paths:
      - 'src/**'
      - 'Cargo.toml'
      - 'Cargo.lock'
      - 'Dockerfile'
      - 'docker-setup.sh'
      - 'gtp_config.cfg.*'
      - 'analysis_config.cfg.*'
      - 'config.toml.example'
      - '.github/workflows/ci.yml'
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

env:
  CARGO_TERM_COLOR: always
  CARGO_INCREMENTAL: 0
  CARGO_NET_RETRY: 10
  RUSTUP_MAX_RETRIES: 10

jobs:
  # ===========================================================================
  # Rust code quality checks
  # ===========================================================================
  check:
    name: Check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - uses: Swatinem/rust-cache@v2
        with:
          shared-key: "rust-cache"
      - run: cargo check --all-features

  test:
    name: Test Suite
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
      - uses: Swatinem/rust-cache@v2
        with:
          shared-key: "rust-cache"
      - uses: taiki-e/install-action@v2
        with:
          tool: cargo-nextest
      - run: cargo nextest run --all-features

  fmt:
    name: Rustfmt
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt
      - run: cargo fmt --all -- --check

  clippy:
    name: Clippy
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy
      - uses: Swatinem/rust-cache@v2
        with:
          shared-key: "rust-cache"
      - run: cargo clippy --all-features -- -D warnings

  # ===========================================================================
  # Docker builds - verify all variants can be built
  # NOTE: Skip on main branch pushes since these tests already run on PRs
  # ===========================================================================
  docker-verify:
    name: Verify Docker Build (${{ matrix.variant }})
    needs: [check, test]  # Start Docker builds early, fmt/clippy can run in parallel
    runs-on: ubuntu-latest
    if: github.event_name != 'push' || github.ref != 'refs/heads/main'

    strategy:
      fail-fast: false
      matrix:
        include:
          - variant: base
            platforms: linux/amd64,linux/arm64
          - variant: cpu
            platforms: linux/amd64,linux/arm64
          - variant: minimal
            platforms: linux/amd64,linux/arm64
          - variant: human-cpu
            platforms: linux/amd64,linux/arm64
          - variant: combo-cpu
            platforms: linux/amd64,linux/arm64

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set image name to lowercase
        id: image
        run: echo "name=$(echo 'ghcr.io/${{ github.repository_owner }}/katago-server' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Extract metadata (tags, labels)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.image.outputs.name }}
          flavor: |
            suffix=${{ matrix.variant == 'base' && '' || format('-{0}', matrix.variant) }},onlatest=true
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=sha
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=${{ matrix.variant }},enable=${{ matrix.variant == 'base' }}
          labels: |
            org.opencontainers.image.title=KataGo Server (${{ matrix.variant }})
            org.opencontainers.image.description=KataGo Server - ${{ matrix.variant }} variant

      - name: Build Docker image (verification only)
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          target: ${{ matrix.variant }}
          push: false
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          platforms: ${{ matrix.platforms }}
          cache-from: |
            type=gha,scope=${{ matrix.variant }}-${{ github.ref_name }}
            type=gha,scope=${{ matrix.variant }}-main
          cache-to: type=gha,mode=max,scope=${{ matrix.variant }}-${{ github.ref_name }}
          provenance: false
          build-args: |
            GIT_SHA=${{ github.sha }}

      # Build CPU image for amd64 only and export for smoke testing
      - name: Build CPU image for testing
        if: matrix.variant == 'cpu'
        uses: docker/build-push-action@v5
        with:
          context: .
          target: cpu
          load: true
          tags: katago-server:test-cpu
          platforms: linux/amd64
          cache-from: |
            type=gha,scope=cpu-${{ github.ref_name }}
            type=gha,scope=cpu-main
          outputs: type=docker,dest=/tmp/cpu-image.tar

      - name: Upload CPU image for testing
        if: matrix.variant == 'cpu'
        uses: actions/upload-artifact@v4
        with:
          name: cpu-docker-image
          path: /tmp/cpu-image.tar
          retention-days: 1

  # ===========================================================================
  # Smoke test - verify CPU variant works
  # NOTE: Skip on main branch pushes since these tests already run on PRs
  # ===========================================================================
  docker-test:
    name: Smoke Test (CPU)
    needs: docker-verify
    runs-on: ubuntu-latest
    if: github.event_name != 'push' || github.ref != 'refs/heads/main'

    steps:
      - name: Download CPU image
        uses: actions/download-artifact@v4
        with:
          name: cpu-docker-image
          path: /tmp

      - name: Load Docker image
        run: docker load --input /tmp/cpu-image.tar

      - name: Create test network
        run: docker network create test-net

      - name: Start container
        run: |
          docker run -d \
            --name test-container \
            --network test-net \
            katago-server:test-cpu

      - name: Wait for startup
        run: sleep 15

      - name: Check container logs
        run: |
          echo "=== Container Logs ==="
          docker logs test-container 2>&1 | tee container.log
          echo "======================"

          # Check for successful startup
          if ! grep -q "Listening on" container.log; then
            echo "ERROR: Server did not start successfully"
            exit 1
          fi

          # Ensure no stderr errors about missing files
          if grep -qi "no such file" container.log; then
            echo "ERROR: Missing files detected in logs"
            exit 1
          fi

      - name: Test health endpoint
        run: |
          docker run --rm --network test-net curlimages/curl:latest \
            curl -f http://test-container:2718/api/v1/health || {
            echo "ERROR: Health check failed"
            exit 1
          }
          echo "Health check passed ✓"

      - name: Test API endpoint
        run: |
          RESPONSE=$(docker run --rm --network test-net curlimages/curl:latest \
            curl -f -X POST http://test-container:2718/api/v1/analysis \
            -H "Content-Type: application/json" \
            -d '{"moves":["R4","D16"],"boardXSize":19,"boardYSize":19,"includeOwnership":true}') || {
            echo "ERROR: API endpoint request failed"
            docker logs test-container
            exit 1
          }

          echo "Response: $RESPONSE"

          # Validate ownership data (should have 361 values for 19x19 board)
          OWNERSHIP_COUNT=$(echo "$RESPONSE" | docker run --rm -i ghcr.io/jqlang/jq:latest '.ownership | length')
          echo "Ownership values count: $OWNERSHIP_COUNT (expected: 361)"
          if [ "$OWNERSHIP_COUNT" != "361" ]; then
            echo "ERROR: Expected 361 ownership values, got $OWNERSHIP_COUNT"
            docker logs test-container
            exit 1
          fi

          # Validate winrate is present and reasonable
          WINRATE=$(echo "$RESPONSE" | docker run --rm -i ghcr.io/jqlang/jq:latest '.rootInfo.winrate')
          echo "Winrate: $WINRATE"
          if [ "$WINRATE" = "null" ] || [ -z "$WINRATE" ]; then
            echo "ERROR: Winrate is null or missing"
            docker logs test-container
            exit 1
          fi

          echo "API test passed ✓"
          echo "  - Ownership values: $OWNERSHIP_COUNT ✓"
          echo "  - Winrate: $WINRATE ✓"

      - name: Cleanup
        if: always()
        run: |
          docker rm -f test-container || true
          docker network rm test-net || true
